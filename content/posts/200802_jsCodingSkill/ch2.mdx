---
title: <자바스크립트 코딩의 기술> ch2
date: 2020-08-02
tags:
  - JS
---

### 배열로 유연한 컬렉션을 생성하라

배열에 이터러블(iterable)이 내장되어 있다. 
iterable은 컬렉션의 현재 위치를 알고 있는 상태에서 컬렉션의 항목을 한 번에 하나씩 처리하는 방법.
문자열, Object.keys( )를 이용해 이터러블로 변환할 수 있는 데이터 형식이라면 배열에 수행하는 모든 동작을 동일하게 실행할 수 있음

###### Object.keys( )

```javascript
// simple array
const arr = ['a', 'b', 'c'];
console.log(Object.keys(arr)); // console: ['0', '1', '2']

// array-like object
const obj = { 0: 'a', 1: 'b', 2: 'c' };
console.log(Object.keys(obj)); // console: ['0', '1', '2']

// array-like object with random key ordering
const anObj = { 100: 'a', 2: 'b', 7: 'c' };
console.log(Object.keys(anObj)); // console: ['2', '7', '100']
```

[Object.keys](https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Global_Objects/Object/keys)

컬렉션 개념의 거의 대부분을 배열형태로 표현가능

###### Object.entries( )

```javascript
const obj = { foo: 'bar', baz: 42 };
console.log(Object.entries(obj)); // [ ['foo', 'bar'], ['baz', 42] ]

// array like object
const obj = { 0: 'a', 1: 'b', 2: 'c' };
console.log(Object.entries(obj)); // [ ['0', 'a'], ['1', 'b'], ['2', 'c'] ]

// array like object with random key ordering
const anObj = { 100: 'a', 2: 'b', 7: 'c' };
console.log(Object.entries(anObj)); // [ ['2', 'b'], ['7', 'c'], ['100', 'a'] ]
```

[Object.entries](https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Global_Objects/Object/entries)

---

### Includes( )로 존재 여부를 확인하라

```javascript
const sections = ['shiping'];

function displayShiping(sections) {
  if(sections.indexOf('shiping')) { // 인덱스가 0이므로 거짓으로 판단
    return true;
  }
  return false;
} // false
```

indexOf는 해당 값의 인덱스 위치를 반환한다. 없으면 -1을 반환한다.  그 점에 유의하여야 함

```javascript
const sections = ['shiping'];

function displayShiping(sections) {
  return sections.indexOf('shiping')>-1
} // true;
```



존재 여부에 대한 true, false의 값을 받기위해서는 includes( )를 이용한다

```javascript
const sections = ['shiping'];

function displayShiping(sections) {
  return sections.includes('shiping');
}
```

---

### 펼침 연산자로 배열을 본떠라

```javascript
const cart = ['Naming and Necessity', 'Alice in Wonderland'];

const copyCart = [...cart];
```

펼침 연산자의 장점은 데이터의 조작이 없음.
읽기 쉽고 간결함
재사용할 수 있으며 예측이 가능함

```javascript
function myFunction(a,b,c){
  return a+b+c;
}

const arr = [1,2,3];
console.log(myFunction(...arr));
```

함수의 매개변수로 전달가능

---

### push( ) 메서드 대신 펼침 연산자로 원본 변경을 피하라

```javascript
const arr = [1,2,3,4];

const ret = [...arr, 5];
arr.push(5);

console.log(ret); // [1,2,3,4,5]
console.log(arr); // [1,2,3,4,5]
```

펼침연산자를 이용하면 원본 데이터의 조작없이 데이터 추가한 새로운 배열 생성이 가능하다

```javascript
const arr = [1,2,3];
const ret = [0,...arr]; // ret : [0,1,2,3]. arr : [1,2,3]
arr.shift(0); // arr : [0,1,2,3]
```

중괄호에 명확하게 어떤 값이 반환되는지 보임으로써 배열을 반환하려는 의도를 표현할 수 있다.

---

### 펼침 연산자로 정렬에 의한 혼란을 피하라

sort( ) 함수는 원본 배열을 조작한다.

그럴떄는 펼침연산자로 사본을 만들어 정렬하면 된다

###### sort

```javascript
arr.sort([compareFunction]);
```

`compareFunction`이 없으면 배열의 요소를 문자열로 변환해서 유니코드 포인트 오름차순으로 정렬한다.

`compareFunction`이 제공되면 배열 요소는 compare 함수의 반환 값에 따라 정렬됩니다. a와 b가 비교되는 두 요소라면,

- `compareFunction(a, b) < 0`  
  : a가 먼저 오게 정렬
- `compareFunction(a, b) > 0`
  : b가 먼저 오게 정렬

[sort](https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Global_Objects/Array/sort)

