---
title: <자바스크립트 코딩의 기술> ch3
date: 2020-08-02
tags:
  - JS
---

### 객체를 이용해 정적인 키-값을 탐색하라

객체는 변호가 없고 구조화된 키-값 데이터를 다루는 경우에 유용하다. 
반면 자주 갱신되거나 실행되기 전에는 알 수 없는 동적인 정보를 다루기에는 적합하지 않다

객체는 정보의 경로를 알고 있을 떄 적절한 방법

---

### Object.assign( )으로 조작 없이 객체를 생성하라

```javascript
const o = {a:1, b:1};
const base = {};
const clone = Object.assign(base,o);
// base == {a:1, b:1} == clone
```

assign( )을 이용하면 원본 객체를 조작한다.

그럴땐

```javascript
const base2 = {};
const clone2 = Object.assign({},base,o);
// base2 == {}
// clone2 == {a:1, b:1}
```



객체가 중첩될 경우 문제가 발생한다. 

```javascript
const defaultEmployee = {
  name : {
    first : '', last : '',
  },
  year : 0,
};
const employee = Object.assign({},defaultEmployee);
employee.name.first = 'tom';
console.log(defaultEmployee.name.first); // 'tom'
```

`year` 의 경우 잘 복사되지만, `name` 의 경우 객체의 참조 주소만 복사하기 때문에 원본, 복사본 모두 중첩된 객체의 값이 변경된다.

객체의 중첩은 안쓰는게 제일 좋지만 불가피한 경우가 있다.
그럴땐

```javascript
const employee2 = Object.assign(
	{},
  defaultEmployee,
  {
    name: Object.assign({},defaultEmployee.name),
  },
);
export {default};
```

### 객체 펼침 연산자로 정보를 갱신하라

```javascript
const defaultObject = {
  a : 1,
  b : 2,
};
const update = { ...defaultObject, c : 3};
// { a:1,b:2,c:3 } 
```

전 주제의 중첩된 객체 문제도 처리가능하다

```javascript
const defaultEmployee = {
  name : {
    first : '', last : '',
  },
  year : 0,
};
const employee = {
  ...defaultEmployee,
  name : {
    ...defaultEmployee.name,
  },
};
```

---

### 맵으로 명확하게 키-값 데이터를 갱신하라

키-값 데이터가 자주 바뀌는 경우엔 객체가 아닌 맵을 이용한다.

```javascript
let filters = new Map() // 체이닝으로 여러 데이터 추가하기
	.set('견종','레브라도레트리버')
	.set('크기','대형견')
	.set('색상','갈색');
filters.get('크기'); // '대형견'
```

배열형태로도 생성이 가능하다

```javascript
let filters = new Map(
  [
    ['견종','래브라도레트리버'],
    ['크기','대형견'],
    ['색상','갈색'],
  ]
)
filters.get('색상'); // '갈색'
```

삭제할 때는

```javascript
filters.delete('색상');

filters.clear();
```



객체의 경우 키에 사용할 수 있는 자료형에 제약이 있다.
정수를 키로 사용할 수 없다. 키를 정수로 쓸 때는 Map!!

---

### 맵과 펼침 연산자로 키-값 데이터를 순회하라

```javascript
const filters = {
  color : 'black',
  type : 'Litriber',
};

function getAppliedFilters(filters) {
  const keys = Object.keys(filters);
  keys.sort(); // 순서를 저장하지 않기 때문에 정렬이 필요
  const applied = [];
  for (const key of keys) {
    applied.push(`${key}:${filters[key]}`);
  }
  return `선택한 조건은 ${applied.join(', ')} 입니다.`;
}
```

객체를 순회하는 것은 쉽지 않다는 것을 알 수 있다.

```javascript
const filters = new Map()
	.set('color', 'black')
	.set('type', 'Litriber');

function checkFilters(filters) {
  for (const entry of filters) {
    console.log(entry);
  }
}
```

Map을 for...of 반복문으로 접근하면 이터레이터는 키-값 쌍을 넘겨준다.

```javascript
filters.entries();
// MapIterator { ['color','black'],['type','Litriber']}
```

맵은 순서를 저장한다. 언제나 맵의 첫 번째 항목을 첫 번째로 받는다. 그러나 배열처럼 정렬 메서드가 내장되어 있지 않다. 
그 문제는 펼침연산자를 통해 해결한다.

```javascript
function sortByKey(a,b){
  return a[0] > b[0] ? 1: -1;
}
function getSortedAppliedFilters(filters) {
  const applied = [];
  for (const [key,value] of [...filters].sort(sortByKey)) {
    applied.push(`${key}:${value}`);
  }
  return `선택한 조건은 ${applied.join(', ')} 입니다.`;
}
```

```javascript
function getSortedAppliedFilters(filters) {
  const applied = [...filters]
  	.sort(sortByKey)
  	.map(([key,value]) => {
      return `${key}:${value}`;
    })
  	.join(', ');
  return `선택한 조건은 ${applied} 입니다.`;
}
```

1. 맵을 배열로 변환
2. 배열을 정렬
3. 배열에 담긴 키-값 쌍을 '키:값' 형식의 문자열로 반환
4. 배열의 항목에 열결해서 문자열을 만듬
5. 템플릿 리터럴을 이용해서 다른 정보와 함께 문자열로 병합

---

### 맵 생성 시 부수효과를 피하라

---

### 세트를 이용해 고유값을 관리하라

```javascript
function getUnique(attributes) {
  return [...new Set(attributes)];
}
```

Set은 중복을 제거하고 저장함