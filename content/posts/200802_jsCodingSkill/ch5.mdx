---
title: <자바스크립트 코딩의 기술> ch5
date: 2020-08-02
tags:
  - JS
---

### 화살표 함수로 반복문을 단순하게 만들어라

```javascript
function capitalize(name) { // 기명함수
  return name[0].toUpperCase() + name.slice(1);
}
```

```javascript
const capitalize = name => name[0].toUpperCase() + name.slice(1);
```

---

### 배열 메서드로 반복문을 짧게 작성하라

- map( )
  형태를 바꿀 수 있지만 길이는 유지
- sort( )
  형태나 길이는 변경되지 않고 순서만 변경
- filter( )
  길이는 변경하지만 형태는 바꾸지 않음
- find( )
  배열을 반환하지 않음
  한 개의 데이터가 반환되고 형태는 바뀌지 않음
- forEach( )
  형태를 이용하지만 아무것도 반환하지 않음
- reduce( )
  길이와 형태를 바꾸는 것을 비롯해서 무엇이든 처리할 수 있음

---

### map( ) 메서드로 비슷한 길이의 배열을 생성하라

맵 함수는 
입력한 배열의 정보 중 한 조각을 받아 새로운 값을 반환, 
정보의 일부를 반환, 
정보를 변형해서 새로운 값을 반환

```javascript
const band = [
{
  name:'corbett',instrument:'guitar',
},
{
  name:'evan',instruement:'guitar',
},
{
  name:'sean',instruement:'bass',
},
]
```

```javascript
function getInstrument(member){
  return member.instrument;
}

const instrument = [];
for (let i=0;i<band.length;i++){
  const instrument = band[i].instrument;
  instruments.push(instrument);
}
```

```javascript
const instruments = band.map(getInstrument);
// ['guitar','guitar','bass']
const instruments = band.map(member => member.instrument);
```


---

### filter( )와 find( )로 데이터의 부분집합을 생성하라


###### filter

```javascript
const scores = [30,82,80,45];
function getNumberOfPassingScores(scores) {
  const passing = scores.filter(score => score > 59);
  // [82,70]
  return passing.length;
}
// 2
```

Filter 메서드는 항상 배열을 반환, 조건에 맞는 값이 없다고 하더라도 빈 배열을 반환함

###### find

참 또는 거짓 값을 반환하는 함수를 인수로 받고, 
배열의 항목에 전달한 함수로 평가해 참 값을 반환하는 첫 번째 항목만 반환
참 값을 반환하는 항목이 없다면 undefined 반환. 그러기 때문에 다낡평가를 이용해 기본값을 추가하는 것이 좋음

```javascript
const image = [{
  path:'./me.jpg',
  profile: false
}];
const profile = images.find(image => image.profile) || {
  path:'./default.jpg'
};
```

---

### forEach( )로 동일한 동작을 적용하라

forEach의 경우 함수의 유효범위를 벗어나는 작업이 필요한 경우, 반드시 부수효과가 필요한 경우에 사용

forEach의 장점은 체이닝 과정에서 다른 배열 메서드와 결합이 가능하고
매번 변수에 배열 메서드의 결괏값을 저장할 필요없이 동일한 배열에서 여러 작업을 처리할 수 있음

```javascript
const names = ['walter','white'];
const capitalized1 = names.forEach(name => name.toUpperCase());
capitalized; // undefined

let capitalized2 = [];
names.forEach(name => capitalized.push(name.toUpperCase()));
capitalized; // ['WALTER','WHITE']
```

---

### 체이닝으로 메서드를 연결하라

값을 다시 할당하지 않고 반환된 객체에 메서드를 즉시 호출하는 것

```javascript
const sailors = [
  {
    name:'yi hong',
    active : true,
    email : 'yh@yhproductionds.io',
  },
  {
    name:'alex',
    active : true,
    email : '',
  },
  {
    name:'nathan',
    active : false,
    email : '',
  },
];

sailors
	.filter(sailor => sailor.active)
	.map(sailor => sailor.email || `${sailor.name}@wiscsail.io`)
	.forEach(sailor => sendEmail(sailor));
```

각 배열 메서드가 고유의 작업을 수행하기 때문에 코드를 한눈에 이해할 수 있음

단점은 새로운 메서드를 호출할 때마다 반환된 배열 전체를 다시 반복함. 대규모 데이터를 다룰 때 고려해야...

세미콜론은 맨 마지막에만 사용할 것
호출되는 메서드에 대한 순서를 지켜야 함

---

### reduce( )로 배열 데이터를 변환하라

```javascript
const callback = function (collectedValues, item) {
  return [...collectedValues, item];
};

const saying = ['veni','vedi','veci'];
const initialValue = [];
const copy = saying.reduce(callback,initialValue);
```

reduce에서 두개의 인수는 반환되는 항복과 개별항목
반환값은 콜백함수가 반환하는 값을 누적한 것.

불린, 배열, 수 등의 다양한 형태로 반환이 가능함

---

### for...in 문과 for...of문으로 반복문을 정리하라

필요한 결과와 일치하지 않아 반복문에서 빠져나오고 싶을 때,
배열이 아닌 컬렉션을 다룰 때 배열 메서드를 사용시 복잡한 경우가 있음

```javascript
const firms = new Map()
	.set(10,'Ivie Group')
	.set(23,'Soundscaping Source')
	.set(31,'Big 6');

const entries = [...firms];
for (let i=0;i<entries.length;i++){
  const [id,name] = entries[i];
  if(!isAvailable(id)){
    return `${name}는 사용할 수 없습니다`;
  }
}
return `모든 회사를 사용할 수 있습니다`;
```

컬렉션을 사용할 경우 배열로의 변환과정이 필요

###### for...of

이터레이터를 사용할 수 있음. 인덱스를 사용하지 않고 컬렉션의 멤버를 직접 순회

```javascript
for (const firm of firms) {
  const [id, name] = firm;
  if(!isAvailable(id)){
    return `${name}는 사용할 수 없습니다`;
  }
}
return `모든 회사를 사용할 수 있습니다`;
```

- 변수 firm을 const로 선언, 유효범위를 갖기 때문에 다른 코드에 영향을 미치지 않음
- 배열 메서드와 같은 개념을 이용해서 개별 항목을 직접 다룰 수 있음
- 배열 변환과정이 없기 떄문에 약간의 최적화
- 예측가능성이 줄어드는 단점

###### for...in

```javascript
const firms = {
  '10':'Ivie Group',
	'23':'Soundscaping Source',
	'31':'Big 6',
}
```

```javascript
for (const id in firms) {
  if(!isAvailable(parseInt(id,10))){
    return `${firms[id]}는 사용할 수 없습니다.`;
  }
}
return '모든 회사를 사용할 수 있습니다';
```

속성을 가져오기 때문에 이름과 값을 따로 추출할 필요가 없음