---
title: Swift 간단 정리 3
date: 2020-08-20
tags:
  - Swift
---

### 상속

- 스위프트의 상속은 클래스, 프로토콜에서 가능
- 다중 상속 불가

```swift
class 이름: 부모클래스 이름 {
  ...
}
```

```swift
class Person {
  var name: String = ""
  
  func selfIntroduce() {
    print("저는 \(name)입니다")
  }
  
  final func sayHello() {
    print("Hello")
  }
  // final 키워드를 통해 자식클래스에서 재정의 불가
  
  // 타입 메서드 - 재정의 불가
  static func typeMethod() {
    print("type method - static")
  }
  // 재정의 가능 메서드
  class func classMethod() {
    print("type method - class")
  }
  // final class라고 표현하면 static과 동일
}

class Student: Person {
  var major: String = ""
  
  override func selfIntroduce() {
    print("저는 \(name)이고, 전공은 \(major)입니다")
  }
  
  override class func classMethod() {
    print("overriden type method - class")
  }
}
```

### 인스턴스의 생성과 소멸

#### 이니셜라이저

스위프트의 모든 인스턴스는 초기화와 동시에 모든 프로퍼티에 유효한 값이 할당되어 있어야 함. 프로퍼티에 미리 기본값을 할당해두면 인스턴스가 생성됨과 동시에 초기값을 지니게 됨

기본값 지정이 어려운 경우 이니셜라이저를 통해 초기값 전달 가능

```swift
class Person {
  var name: String
  var age: Int
  var nickName: String?
  
  convenience init(name: String, age:Int, nickName: String){
    //self.name = name
    //self.age = age
    // 자기 자신의 이니셜라이저 호출 가능
    self.init(name: name, age: age)
    self.nickName = nickName
  }
  
  // 기본값 설정이 꼭 필요하지 않다면 옵셔널을 활용
  init(name: String, age:Int) {
    self.name = name
    self.age = age
  }
}

let hana: Person = Person(name: "hana", age: 20, nickName: "하나")
```

**실패 가능한 이니셜라이저**

```swift
class Person2 {
  var name: String
  var age: Int
  var nickName: String?
  
  init?(name: String, age: Int) {
    if (0...120).contains(age) == false {
      return nil
    }
    if name.characters.count == 0 {
      return nil
    }
    
    self.name = name
    self.age = age
  }
}

let john: Person2? = Person2(name:"john", age:23)
```

#### 디이니셜라이저

클래스의 인스턴스가 메모리에서 해제되는 시점에 호출

```swift
class Person3 {
  var name: String
  var age: Int
  
  init(name: String, age:Int) {
    self.name = name
    self.age = age
  }
  deinit {
    ...
  }
}
```



### 옵셔널 체이닝

옵셔널 요소 내부의 프로퍼티로 또다시 옵셔널이 연속적으로 연결되는 경우 유용하게 사용

```swift
class Person {
  var name: String
  var job: String?
  var home: Apartment?
  
  init(name: String){
    self.name = name
  }
}

class Apartment {
  var buildingNumber: String
  var roomNumber: String
  var `guard`: Person?
  var owner: Person?
  
  init(dong: String, ho: String) {
    buildingNumber = dong
    roomNumber = ho
  }
}

func guardJobWithOptionalChaining(owner: Person?) {
  if let guardJob = owner?.home?.guard?.job {
    print("우리집 경비원의 직업은 \(guardJob)입니다")
  } else {
    print("우리집 경비원은 직업이 없어요")
  }
}
```

#### nil 병합 연산자

```swift
var guardJob: String

// x ?? y : x가 nil이라면 y를 할당하라
guardJob = yagom?.home?.guard?.job ?? "슈퍼맨"
print(guardJob) // 슈퍼맨
```



### 타입캐스팅

스위프트의 타입캐스팅은 인스턴스의 타입을 확인하는 용도 또는 클래스의 인스턴스를 부모 혹은 자식 클래스 타입으로 사용할 수 있는지 확인하는 용도로 사용

`is` , `as` 를 사용

```swift
class Person {
  ...
}
class Student: Person {
  ...
}
class UnivStudent: Student {
  ...
}

var me: Person = Person()
var hana: Student = Student()
var jason: UnivStudent = UnivStudent()

var result: Bool

result = me is Person // true
result = me is Student // false
result = me is UnivStudent // false

result = hana is Person // true
result = hana is Student // true
result = hana is UnivStudent // false

result = jason is Person // true
result = jason is Student // true
result = jason is UnivStudent // true
```

#### 업캐스팅

- `as` 를 사용하여 부모클래스의 인스턴스로 사용할 수 있도록 컴파일러에게 타입정보를 전환해줌
- `Any`, `AnyObject`로도 타입정보를 변환할 수 있음
- 암시적으로 처리되므로 생략가능

```swift
var mike: Person = UnivStudent() as Person
var jenny: Student = Student()
var jina: Any = Person()
```

#### 다운캐스팅

- 자식 클래스의 인스턴스로 사용할 수 있도록 타입정보 전화
- `as?` 조건부 다운 캐스팅

```swift
var optionalCasted: Student?

optionalCasted = mike as? UnivStudent 
optionalCasted = jenny as? UnivStudent // nil
optionalCasted = jina as? UnivStudent // nil
optionalCasted = jina as? Student // nil
```

- `as!` 강제 다운 캐스팅

```swift
var forcedCasted: Student

forcedCasted = mike as! UnivStudent
forcedCasted = jenny as? UnivStudent // error
forcedCasted = jina as? UnivStudent // error
forcedCasted = jina as? Student // erro
```



### assert와 guard

애플리케이션이 동작 도중에 생성하는 다양한 결과값을 동적으로 확인하고 안전하게 처리할 수 있도록 도와줌

#### assertion

- `assert(_: _: file : line: )` 함수를 사용
- 디버깅 모드에서만 동작
- 배포하는 애플리케이션에서는 제외됨

```swift
var someInt: Int = 0

assert(someInt == 0, "someInt != 0")

someInt = 1
// 동작 중지, 검증 실패
// assertion failed: someInt != 0: ...
```

#### Early Exit

- `guard` 를 사용하여 잘못된 값의 전달 시 특정 실행구문을 빠르게 종료
- 디버깅모드 뿐만 아니라 어떤 조건에서도 동작
- `else` 블록에는 종료 지시어가 반드시 있어야 함
- 옵셔널과 함께 많이 쓰인다.

```swift
func functionWithGuard(age: Int?) {
	guard let unwrappedAge = age,
  	unwrappedAge < 130, unwrappedAge >=0 else {
      print("나이값 입력이 잘못되었습니다")
      return 
    }
  
  print("당신의 나이는 \(unwrappedAge)세 입니다")
}
```



### 프로토콜

- 프로토콜은 특정 역할을 수행하기 위한 메서드, 프로퍼티, 이니셜라이저 등의 요구사항을 정의
- 구조체, 클래스, 열거형은 프로토콜을 채택해서 프로토콜의 요구사항을 실제로 구현할 수 있음
- 자바의 인터페이스 느낌인듯..

```swift
protocol 이름 {
  ...
}
```

- 상속도 가능. 다중상속 가능
- `is` , `as` 키워드 사용 가능

### 익스텐션

- 여러타입에 새로운 기능을 추가할 수 있는 기능
- 연산 프로퍼티, 타입 메서드, 이니셜라이저, 서브스크립트, 중첩타입, 특정 프로토콜 등을 추가 가능

```swift
extension 확장할 타입 {
  ...
}
extension 확장할 타입 : 프로토콜1, 프로토콜2 {
  ...
}
```



### 오류처리

오류표현 방법은 Error 프로토콜과 열거형을 통해서 오류를 표현

```swift
enum 오류종류이름: Error {
  case 종류1
  case 종류2
}
```

- 오류가 발생할 가능성이 있는 부분에 `throw` 키워드를 추가

- `try` 를 사용하여 호출

  - Do-catch

  ```swift
  do { 
    try ...
  } catch Error.xxx {
    
  }
  ```

  

  - `try?` : 별도의 오류결과를 받지 않고 `nil`로 받음
  - `try!` : 오류가 발생하지 않을 것이라는 확신을 가질 때 사용. 오류발생하면 런타임 오류 발생

### 고차함수

전달인자로 함수를 받거나 함수실행의 결과를 함수로 반환하는 함수

#### map

```swift
var numbers: [Int] = [0,1,2,3,4]
var doubledNumbers: [Int] = [Int]()

doubledNumbers = numbers.map({ (number: Int) -> Int in
   return number*2                         
})


print(doubledNumbers) // [0,2,4,6,8]
```

#### filter

```swift
let evenNumbers: [Int] = numbers.filter{
  (number: Int) -> Bool in
  return number %2 == 0
}

let oddNumbers: [Int] = numbers.filter{
  $0 %2 != 0
}
```

조건에 맞는 값들을 걸러내어 새로운 배열로 반환. 상수로 바로 받을 수도 있음

#### reduce

```swift
let someNumbers: [Int] = [2,8,15]

let sum: Int = someNumbers.reduce(0, {
  (first: Int, second: Int) -> Int in
  return first + second
}) // 초기값이 0
```

