---
title: <자바스크립트 코딩의 기술> ch8
date: 2020-08-03
tags:
  - JS
---

### 읽기 쉬운 클래스를 만들어라

```javascript
class Coupon {
  constructor(price, expiration){
    this.price = price;
    this.expiration = expiration || '2주';
  }
  getPriceText() {
    return `$ ${this.price}`;
  }
  getExpirationMessage(){
    return ` 이 쿠폰은 ${this.expiration} 후에 만료됩니다.`;
  }
  isRewardsEligible(user){
    return user.rewardsEligible && user.active;
  }
  getRewards(user){
    if (this.isRewardsEligible(user)) {
      this.price = this.price * 0.9;
    }
  }
}

export default Coupon;
```

```javascript
// 새로운 인스턴스 생성
const coupon = new Coupon(); 
coupon.price;
// 5
coupon['expiration'];
// '2주'

const coupon2 = new Coupon(5);
coupon2.getPriceText();
// '$ 5'
```



- 생성자
  생성자의 역할 중 하나는 this 문맥을 생성하는 것
  생성자에 인수를 전달할 수 있기 때문에 새로운 인스턴스를 생성할 때 속성을 동적으로 설정할 수 있음
  모든 속성은 공개 속성


---


### 상속으로 메서드를 공유하라

```javascript
import Coupon from './Coupon.js'
class FlashCoupon extends Coupon {
	constructor(price,expiration) {
    super(price);
    this.expiration = expiration || '2시간';
  }
  getExpirationMessage() {
    return `이 쿠폰은 깜짝 쿠폰이며 ${this.expiration} 후에 만료됩니다.`''
  }
  isRewardsEligible(user){
    return super.isRewardsEligible(user) && this.price > 20;
  }
  getRewards(user){
    if (this.isRewardsEligible(user)){
      this.price = this.price*0.8;
    }
  }
}
export {FlashCoupon};
```

```javascript
const flash = new FlashCoupon(10);
flash.price;
// 10
flash.getPriceText();
// "$ 10"
flash.getExpirationMessage();
// "이 쿠폰은 2시간 후에 만료됩니다"
```

- super( )는 부모 클래스의 생성자를 호출하기 때문에 부모 클래스의 생성자에 필요한 인수가 있다면 super( )를 이용해서 넘겨줄 수 있음.
- 클래스에 같은 이름의 메서드를 새로 작성하면 부모 클래스에서 상속한 메서드를 대체


---


### 클래스로 기존의 프로토타입을 확장하라

전통적인 객체 지향 언어에서 클래스를 사용하는 경우에는 클래스가 객체를 위한 청사진이 된다.
새로운 인스턴스를 생성하면 새로운 객체에 모든 속성과 메서드가 복제됨

자바스크립트는 프로토타입 언어로 새로운 인스턴스를 생성할 때 메서드를 복제하지 않음
그 대신 프로토타입에 대한 연결을 생성.
객체의 인스턴스에 있는 메서드를 호출하면 프로토타입에 있는 메서드를 호출

###### 생성자 함수를 이용해 객체 인스턴스 만들기

```javascript
function Coupon(price, expiration) {
  this.prce = price;
  this.expiration = expiration || '2주';
}
const coupon = new Coupon(5,'2개월');
coupon.price;
// 5
```

new 키워드로 새로운 인스턴스를 생성할 때, 생성자를 실행하고 this 문맥을 바인딩하지만 메서드를 복제하지는 않음

프로토타입은 생성자 함수의 가반이 되는 객체
모든 객체 인스턴스는 프로토타입에서 속성을 가져옴. 게다가 새로운 인스턴스도 프로토타입에 있는 메서드를 사용할 수 있음

```javascript
Coupon.prototype.getExpirationMessage = function() {
  return `이 쿠폰은 ${this.expiration} 후에 만료됩니다.`;
};
coupon.getExpirationMessage();
// 이 쿠폰은 2개월 후에 만료됩니다.
```

클래스 방식과 생성자 함수, 프로토타입을 이용한 방식은 내부적으로는 동일하다.
프로토타입을 이용해서 생성한 레거시 코드에 새로운 코드를 추가할 때 클래스를 사용할 수도 있음



---


### get과 set으로 인터페이스를 단순하게 만들어라

자바스크립트의 주요 문제점 중 하나는 비공개 속성을 기본적으로 지원하지 않는 것
이에 대한 한가지 해결책으로 게터와 세터를 이용하는 것

```javascript
class Coupon {
  constructor(price, expiration) {
    this.price = price;
    this.expiration = expiration || '2주';
  }
  get priceText() {
    return `${this.price}`;
  }
  get expirationMessage() {
    return `이 쿠폰은 ${this.expiration} 후에 만료됩니다.`
  }
  set halfPrice(price) {
    this.price = price /2;
  }
}
```

```javascript
const coupon = new Coupon(5);
coupon.price = 10;
coupon.priceText;
// '$10'
coupon.messageText;
// '이 쿠폰은 2주 후에 만료됩니다.'

coupon.halfPrice = 20;
coupon.price;
// 10
coupon.halfPrice;
// undefined
```

get 키워드를 추가함으로써 메서드를 속성처럼 사용이 가능하다. 괄호가 필요없다
그러나 여전히 값의 변경이 가능하다.

set 키워드를 통해 세터를 설정한다.
세터의 경우 인수를 하나만 받고 인수 전달 시 등호를 사용한다.
그러나 속성이 아니기 때문에 그냥 세터를 호출하면 `undefined`

그렇다고 게터와 세터에 동일한 이름을 부여하면 무한으로 스택에 쌓이는 문제가 발생
해결책은 다른 속성을 게터와 세터의 가교로 사용하는 것
이름 앞에 밑줄을 입력해 비공개라는 것을 표시

```javascript
class Coupon {
  constructor(price, expiration) {
    this._price = price;
    this.expiration = expiration || '2주';
  }
  get priceText() {
    return `$${this._price}`;
  }
  get price() {
    return this._price;
  }
  set price(price) {
    const newPrice = price;
    	.toString()
    	.replace(/[^\d]/g,'');
    this._price = parseInt(newPrice,10);
  }
  get expirationMessage() {
    return `이 쿠폰은 ${this.expiration} 후에 만료됩니다.`
  }
}
const coupon = new Coupon(5);
coupon.price;
// 5
coupon.price = '$10';
coupon.price;
// 10
coupon.priceText;
// $ 10

export default Coupon
```


---


### 제너레이터로 이터러블 속성을 생성하라

###### 제너레이터

함수가 호출되었을 때 그 즉시 끝까지 실행하지 않고 중간에 빠져나갔다가 다시 돌아올 수 있는 함수
다음 단계 전까지 기본적으로 일시 정지하는 중단점이 있는 함수

제너레이터를 생성하려면 `function*`
이렇게 하면 함수의 일부를 반환하는 `next()`라는 특별한 함수에 접근할 수 있음
함수 몸체 안에서는 `yield` 키워드를 이용해 정보를 반환. 
함수를 실행할 때는 next( ) 메서드를 이용해서 함수가 내보낸 정보를 가져올 수 있음

`next()`를 호출하면 두 개의 키 `value`와 `done`이 있는 객체를 가져옴
`yield`로 선언한 항목이 `value`. `done`은 남은 항목이 없다는 것을 알려줌

```javascript
function* getCairoTrilogy(){
  yield '궁전 샛길';
  yield '욕망의 궁전';
  yield '설탕 거리';
}

const trilogy = getCairoTrilogy();
trilogy.next();
// { value : '궁전 샛길', done : false }
trilogy.next();
// { value : '욕망의 궁전', done : false }
trilogy.next();
// { value : '설탕 거리', done : true }
trilogy.next();
// { value : undefined, done : true }
```

```javascript
[...getCairoTrilogy()];
// ['궁전 샛길','욕망의 궁전','설탕 거리']
```

###### 클래스에서의 제너레이터 활용

```javascript
class FamilyTree {
  constructor(){
    this.family = {
      name:'Doris',
      child: {
        name:'Martha',
        child:{
          name:'Dyam',
          child:{
            name:'Bea',
          },
        },
      },
    };
  }
  *[Symbol.iterator]() {
    let node = this.family;
    while(node){
      yield node.name;
      node = node.child;
    }
  }
}

const family = new FamilyTree();
[...family];
// ['Doris','Martha','Dyan','Bea']
```

---

### bind( )로 문맥 문제를 해결하라

