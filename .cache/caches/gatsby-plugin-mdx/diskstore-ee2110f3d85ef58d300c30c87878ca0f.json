{"expireTime":9007200851285484000,"key":"gatsby-plugin-mdx-entire-payload-b5e39a234c0aeebaebfefcbf7c73f8d0-","val":{"mdast":{"type":"root","children":[{"type":"heading","depth":5,"children":[{"type":"text","value":"생성","position":{"start":{"line":3,"column":7,"offset":8},"end":{"line":3,"column":9,"offset":10},"indent":[]}}],"position":{"start":{"line":3,"column":1,"offset":2},"end":{"line":3,"column":9,"offset":10},"indent":[]}},{"type":"code","lang":"c++","meta":null,"value":"vector<int> v1;\t// 빈 벡터 생성\nvector<int> v2(5); // 사이즈가 5인 벡터 생성, 전부 0\nvector<int> v3(5,1);\t// 사이즈가 5이고 전부 1\nvector<int> v4(v2);\t// v2를 복사해서 v4 생성","position":{"start":{"line":5,"column":1,"offset":12},"end":{"line":10,"column":4,"offset":167},"indent":[1,1,1,1,1]}},{"type":"heading","depth":5,"children":[{"type":"text","value":"추가 / 삭제","position":{"start":{"line":14,"column":7,"offset":177},"end":{"line":14,"column":14,"offset":184},"indent":[]}}],"position":{"start":{"line":14,"column":1,"offset":171},"end":{"line":14,"column":14,"offset":184},"indent":[]}},{"type":"code","lang":"c++","meta":null,"value":"v1.push_back(1);\t// 벡터 뒤에 1을 추가\nv1.pop_back();\t// 벡터 맨 뒤 원소 삭제\n\nv1.clear();\t// 모든 원소 삭제. 원소만 제거하고 메모리는 남아있음\n\nv1.erase(vec1.begin(), vec1.end()); //[a, b) 주소 구간에 해당하는 원소 삭제\nv1.erase(iter);\t// iter가 가리키는 원소 삭제\n  \nv1.insert(n,m); // n번쨰 자리에 m값을 삽입\nv1.insert(a,b,c); // a번째 자리에 b개의 c값을 삽입","position":{"start":{"line":16,"column":1,"offset":186},"end":{"line":27,"column":4,"offset":481},"indent":[1,1,1,1,1,1,1,1,1,1,1]}},{"type":"heading","depth":5,"children":[{"type":"text","value":"할당 / 사이즈 관련","position":{"start":{"line":31,"column":7,"offset":491},"end":{"line":31,"column":18,"offset":502},"indent":[]}}],"position":{"start":{"line":31,"column":1,"offset":485},"end":{"line":31,"column":18,"offset":502},"indent":[]}},{"type":"code","lang":"c++","meta":null,"value":"v1.assign(m,n);\t// m 사이즈의 벡터 할당, 값은 전부 n\n  \nv1.size();\t// 벡터 원소 갯수 반환\nv1.capacity();\t// 벡터가 할당된 크기 반환, size랑은 다름\n  \nv1.resize(n)\t// 벡터 n으로 크기 재설정\n  \nv1.empty();\t// 비었으면 true 아니면 false","position":{"start":{"line":33,"column":1,"offset":504},"end":{"line":42,"column":4,"offset":698},"indent":[1,1,1,1,1,1,1,1,1]}},{"type":"heading","depth":5,"children":[{"type":"text","value":"참조","position":{"start":{"line":46,"column":7,"offset":708},"end":{"line":46,"column":9,"offset":710},"indent":[]}}],"position":{"start":{"line":46,"column":1,"offset":702},"end":{"line":46,"column":9,"offset":710},"indent":[]}},{"type":"code","lang":"c++","meta":null,"value":"v1.at(idx);\t// idx번째 원소 참조. 범위 점검하기 때문에 안전\nv1[idx];\t// idx번째 원소 참조. 범위 점검 안하기 때문에 빠름\n  \nv1.front();\t// 첫번째 원소 참조\nv1.back();\t// 마지막 원소 참조\n  \nv1.begin();\t// 벡터의 첫 원소의 주소\nv1.end();\t// 마지막 원소의 다음 주소 리턴","position":{"start":{"line":48,"column":1,"offset":712},"end":{"line":57,"column":4,"offset":920},"indent":[1,1,1,1,1,1,1,1,1]}},{"type":"export","value":"export const _frontmatter = {\"title\":\"CPP STL - Vector\",\"date\":\"2020-08-04T00:00:00.000Z\",\"tags\":[\"CPP\"]}","position":{"start":{"line":61,"column":1,"offset":924},"end":{"line":61,"column":106,"offset":1029},"indent":[]}}],"position":{"start":{"line":1,"column":1,"offset":0},"end":{"line":61,"column":106,"offset":1029}}},"scopeImports":["import * as React from 'react'"],"scopeIdentifiers":["React"],"body":"function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsx mdx */\nvar _frontmatter = {\n  \"title\": \"CPP STL - Vector\",\n  \"date\": \"2020-08-04T00:00:00.000Z\",\n  \"tags\": [\"CPP\"]\n};\n\nvar makeShortcode = function makeShortcode(name) {\n  return function MDXDefaultShortcode(props) {\n    console.warn(\"Component '\" + name + \"' was not imported, exported, or provided by MDXProvider as global scope\");\n    return mdx(\"div\", props);\n  };\n};\n\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, [\"components\"]);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"h5\", null, \"\\uC0DD\\uC131\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-c++\"\n  }), \"vector<int> v1; // \\uBE48 \\uBCA1\\uD130 \\uC0DD\\uC131\\nvector<int> v2(5); // \\uC0AC\\uC774\\uC988\\uAC00 5\\uC778 \\uBCA1\\uD130 \\uC0DD\\uC131, \\uC804\\uBD80 0\\nvector<int> v3(5,1);    // \\uC0AC\\uC774\\uC988\\uAC00 5\\uC774\\uACE0 \\uC804\\uBD80 1\\nvector<int> v4(v2); // v2\\uB97C \\uBCF5\\uC0AC\\uD574\\uC11C v4 \\uC0DD\\uC131\\n\")), mdx(\"h5\", null, \"\\uCD94\\uAC00 / \\uC0AD\\uC81C\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-c++\"\n  }), \"v1.push_back(1);    // \\uBCA1\\uD130 \\uB4A4\\uC5D0 1\\uC744 \\uCD94\\uAC00\\nv1.pop_back();  // \\uBCA1\\uD130 \\uB9E8 \\uB4A4 \\uC6D0\\uC18C \\uC0AD\\uC81C\\n\\nv1.clear(); // \\uBAA8\\uB4E0 \\uC6D0\\uC18C \\uC0AD\\uC81C. \\uC6D0\\uC18C\\uB9CC \\uC81C\\uAC70\\uD558\\uACE0 \\uBA54\\uBAA8\\uB9AC\\uB294 \\uB0A8\\uC544\\uC788\\uC74C\\n\\nv1.erase(vec1.begin(), vec1.end()); //[a, b) \\uC8FC\\uC18C \\uAD6C\\uAC04\\uC5D0 \\uD574\\uB2F9\\uD558\\uB294 \\uC6D0\\uC18C \\uC0AD\\uC81C\\nv1.erase(iter); // iter\\uAC00 \\uAC00\\uB9AC\\uD0A4\\uB294 \\uC6D0\\uC18C \\uC0AD\\uC81C\\n  \\nv1.insert(n,m); // n\\uBC88\\uCA30 \\uC790\\uB9AC\\uC5D0 m\\uAC12\\uC744 \\uC0BD\\uC785\\nv1.insert(a,b,c); // a\\uBC88\\uC9F8 \\uC790\\uB9AC\\uC5D0 b\\uAC1C\\uC758 c\\uAC12\\uC744 \\uC0BD\\uC785\\n\")), mdx(\"h5\", null, \"\\uD560\\uB2F9 / \\uC0AC\\uC774\\uC988 \\uAD00\\uB828\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-c++\"\n  }), \"v1.assign(m,n); // m \\uC0AC\\uC774\\uC988\\uC758 \\uBCA1\\uD130 \\uD560\\uB2F9, \\uAC12\\uC740 \\uC804\\uBD80 n\\n  \\nv1.size();  // \\uBCA1\\uD130 \\uC6D0\\uC18C \\uAC2F\\uC218 \\uBC18\\uD658\\nv1.capacity();  // \\uBCA1\\uD130\\uAC00 \\uD560\\uB2F9\\uB41C \\uD06C\\uAE30 \\uBC18\\uD658, size\\uB791\\uC740 \\uB2E4\\uB984\\n  \\nv1.resize(n)    // \\uBCA1\\uD130 n\\uC73C\\uB85C \\uD06C\\uAE30 \\uC7AC\\uC124\\uC815\\n  \\nv1.empty(); // \\uBE44\\uC5C8\\uC73C\\uBA74 true \\uC544\\uB2C8\\uBA74 false\\n\")), mdx(\"h5\", null, \"\\uCC38\\uC870\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-c++\"\n  }), \"v1.at(idx); // idx\\uBC88\\uC9F8 \\uC6D0\\uC18C \\uCC38\\uC870. \\uBC94\\uC704 \\uC810\\uAC80\\uD558\\uAE30 \\uB54C\\uBB38\\uC5D0 \\uC548\\uC804\\nv1[idx];    // idx\\uBC88\\uC9F8 \\uC6D0\\uC18C \\uCC38\\uC870. \\uBC94\\uC704 \\uC810\\uAC80 \\uC548\\uD558\\uAE30 \\uB54C\\uBB38\\uC5D0 \\uBE60\\uB984\\n  \\nv1.front(); // \\uCCAB\\uBC88\\uC9F8 \\uC6D0\\uC18C \\uCC38\\uC870\\nv1.back();  // \\uB9C8\\uC9C0\\uB9C9 \\uC6D0\\uC18C \\uCC38\\uC870\\n  \\nv1.begin(); // \\uBCA1\\uD130\\uC758 \\uCCAB \\uC6D0\\uC18C\\uC758 \\uC8FC\\uC18C\\nv1.end();   // \\uB9C8\\uC9C0\\uB9C9 \\uC6D0\\uC18C\\uC758 \\uB2E4\\uC74C \\uC8FC\\uC18C \\uB9AC\\uD134\\n\")));\n}\n;\nMDXContent.isMDXComponent = true;","rawMDXOutput":"/* @jsx mdx */\nimport { mdx } from '@mdx-js/react';\n/* @jsx mdx */\n\nexport const _frontmatter = {\n  \"title\": \"CPP STL - Vector\",\n  \"date\": \"2020-08-04T00:00:00.000Z\",\n  \"tags\": [\"CPP\"]\n};\nconst makeShortcode = name => function MDXDefaultShortcode(props) {\n  console.warn(\"Component '\" + name + \"' was not imported, exported, or provided by MDXProvider as global scope\")\n  return <div {...props}/>\n};\n\nconst layoutProps = {\n  _frontmatter\n};\nconst MDXLayout = \"wrapper\"\nexport default function MDXContent({\n  components,\n  ...props\n}) {\n  return <MDXLayout {...layoutProps} {...props} components={components} mdxType=\"MDXLayout\">\n    <h5>{`생성`}</h5>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-c++\"\n      }}>{`vector<int> v1; // 빈 벡터 생성\nvector<int> v2(5); // 사이즈가 5인 벡터 생성, 전부 0\nvector<int> v3(5,1);    // 사이즈가 5이고 전부 1\nvector<int> v4(v2); // v2를 복사해서 v4 생성\n`}</code></pre>\n    <h5>{`추가 / 삭제`}</h5>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-c++\"\n      }}>{`v1.push_back(1);    // 벡터 뒤에 1을 추가\nv1.pop_back();  // 벡터 맨 뒤 원소 삭제\n\nv1.clear(); // 모든 원소 삭제. 원소만 제거하고 메모리는 남아있음\n\nv1.erase(vec1.begin(), vec1.end()); //[a, b) 주소 구간에 해당하는 원소 삭제\nv1.erase(iter); // iter가 가리키는 원소 삭제\n  \nv1.insert(n,m); // n번쨰 자리에 m값을 삽입\nv1.insert(a,b,c); // a번째 자리에 b개의 c값을 삽입\n`}</code></pre>\n    <h5>{`할당 / 사이즈 관련`}</h5>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-c++\"\n      }}>{`v1.assign(m,n); // m 사이즈의 벡터 할당, 값은 전부 n\n  \nv1.size();  // 벡터 원소 갯수 반환\nv1.capacity();  // 벡터가 할당된 크기 반환, size랑은 다름\n  \nv1.resize(n)    // 벡터 n으로 크기 재설정\n  \nv1.empty(); // 비었으면 true 아니면 false\n`}</code></pre>\n    <h5>{`참조`}</h5>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-c++\"\n      }}>{`v1.at(idx); // idx번째 원소 참조. 범위 점검하기 때문에 안전\nv1[idx];    // idx번째 원소 참조. 범위 점검 안하기 때문에 빠름\n  \nv1.front(); // 첫번째 원소 참조\nv1.back();  // 마지막 원소 참조\n  \nv1.begin(); // 벡터의 첫 원소의 주소\nv1.end();   // 마지막 원소의 다음 주소 리턴\n`}</code></pre>\n\n    </MDXLayout>;\n}\n\n;\nMDXContent.isMDXComponent = true;"}}