{"expireTime":9007200852000339000,"key":"gatsby-plugin-mdx-entire-payload-36fb9c7e539239318ff336c42db46caa-","val":{"mdast":{"type":"root","children":[{"type":"paragraph","children":[{"type":"text","value":"SVM은 분류, 회귀에 사용할 수 있는 기계학습 알고리즘.","position":{"start":{"line":2,"column":1,"offset":1},"end":{"line":2,"column":33,"offset":33},"indent":[]}}],"position":{"start":{"line":2,"column":1,"offset":1},"end":{"line":2,"column":33,"offset":33},"indent":[]}},{"type":"paragraph","children":[{"type":"text","value":"n차원 공간에 있는 각 데이터를, 가장 잘 구분하는 초평면, 경계선 또는 면을 찾는 것","position":{"start":{"line":4,"column":1,"offset":35},"end":{"line":4,"column":49,"offset":83},"indent":[]}}],"position":{"start":{"line":4,"column":1,"offset":35},"end":{"line":4,"column":49,"offset":83},"indent":[]}},{"type":"paragraph","children":[{"type":"text","value":"SVM은 Margin (초평면에서 가장 가까이에 있는 점과 초평면사이의 거리)을 우선으로 해서 분류","position":{"start":{"line":6,"column":1,"offset":85},"end":{"line":6,"column":56,"offset":140},"indent":[]}}],"position":{"start":{"line":6,"column":1,"offset":85},"end":{"line":6,"column":56,"offset":140},"indent":[]}},{"type":"paragraph","children":[{"type":"text","value":"SVM은 선형분류와 비선형분류에 사용","position":{"start":{"line":8,"column":1,"offset":142},"end":{"line":8,"column":21,"offset":162},"indent":[]}}],"position":{"start":{"line":8,"column":1,"offset":142},"end":{"line":8,"column":21,"offset":162},"indent":[]}},{"type":"paragraph","children":[{"type":"text","value":"비선형 분류를 하기 위해서는 주어진 데이터를 고차원 특징 공간으로 사상하는 작업이 필요하다.\n이 작업을 효율적으로 실행하기 위해 커널을 이용","position":{"start":{"line":12,"column":1,"offset":166},"end":{"line":13,"column":27,"offset":244},"indent":[1]}}],"position":{"start":{"line":12,"column":1,"offset":166},"end":{"line":13,"column":27,"offset":244},"indent":[1]}},{"type":"paragraph","children":[{"type":"text","value":"주요 커널은 Linear Kernel, Polynomial Kernel, Radial Basis Function","position":{"start":{"line":17,"column":1,"offset":248},"end":{"line":17,"column":63,"offset":310},"indent":[]}}],"position":{"start":{"line":17,"column":1,"offset":248},"end":{"line":17,"column":63,"offset":310},"indent":[]}},{"type":"paragraph","children":[{"type":"text","value":"커널의 파라미터를 적절히 조절하여 오버피팅을 막아야 함","position":{"start":{"line":19,"column":1,"offset":312},"end":{"line":19,"column":31,"offset":342},"indent":[]}}],"position":{"start":{"line":19,"column":1,"offset":312},"end":{"line":19,"column":31,"offset":342},"indent":[]}},{"type":"heading","depth":3,"children":[{"type":"text","value":"소프트 마진 선형 SVM 분류","position":{"start":{"line":21,"column":5,"offset":348},"end":{"line":21,"column":21,"offset":364},"indent":[]}}],"position":{"start":{"line":21,"column":1,"offset":344},"end":{"line":21,"column":21,"offset":364},"indent":[]}},{"type":"paragraph","children":[{"type":"text","value":"Hard Margin 분류는 완벽하게 분류하지만 몇 개의 노이즈로 인해 초평면을 잘못 구할 수도 있음","position":{"start":{"line":23,"column":1,"offset":366},"end":{"line":23,"column":57,"offset":422},"indent":[]}}],"position":{"start":{"line":23,"column":1,"offset":366},"end":{"line":23,"column":57,"offset":422},"indent":[]}},{"type":"paragraph","children":[{"type":"text","value":"이에 대한 보완으로 Soft margin. 서포트 벡터가 위치한 경계선에 여유 변수를 두어 노이즈들을 무시하고 초평면을 그림","position":{"start":{"line":25,"column":1,"offset":424},"end":{"line":25,"column":70,"offset":493},"indent":[]}}],"position":{"start":{"line":25,"column":1,"offset":424},"end":{"line":25,"column":70,"offset":493},"indent":[]}},{"type":"list","ordered":false,"start":null,"spread":false,"children":[{"type":"listItem","spread":false,"checked":null,"children":[{"type":"paragraph","children":[{"type":"text","value":"Primal 공식","position":{"start":{"line":27,"column":3,"offset":497},"end":{"line":27,"column":12,"offset":506},"indent":[]}}],"position":{"start":{"line":27,"column":3,"offset":497},"end":{"line":27,"column":12,"offset":506},"indent":[]}}],"position":{"start":{"line":27,"column":1,"offset":495},"end":{"line":27,"column":12,"offset":506},"indent":[]}},{"type":"listItem","spread":false,"checked":null,"children":[{"type":"paragraph","children":[{"type":"text","value":"Dual 공식","position":{"start":{"line":28,"column":3,"offset":509},"end":{"line":28,"column":10,"offset":516},"indent":[]}}],"position":{"start":{"line":28,"column":3,"offset":509},"end":{"line":28,"column":10,"offset":516},"indent":[]}}],"position":{"start":{"line":28,"column":1,"offset":507},"end":{"line":28,"column":10,"offset":516},"indent":[]}}],"position":{"start":{"line":27,"column":1,"offset":495},"end":{"line":28,"column":10,"offset":516},"indent":[1]}},{"type":"heading","depth":3,"children":[{"type":"text","value":"많이 사용하는 커널","position":{"start":{"line":30,"column":5,"offset":522},"end":{"line":30,"column":15,"offset":532},"indent":[]}}],"position":{"start":{"line":30,"column":1,"offset":518},"end":{"line":30,"column":15,"offset":532},"indent":[]}},{"type":"list","ordered":false,"start":null,"spread":false,"children":[{"type":"listItem","spread":false,"checked":null,"children":[{"type":"paragraph","children":[{"type":"text","value":"Linear Kernel","position":{"start":{"line":32,"column":3,"offset":536},"end":{"line":32,"column":16,"offset":549},"indent":[]}}],"position":{"start":{"line":32,"column":3,"offset":536},"end":{"line":32,"column":16,"offset":549},"indent":[]}}],"position":{"start":{"line":32,"column":1,"offset":534},"end":{"line":32,"column":16,"offset":549},"indent":[]}},{"type":"listItem","spread":false,"checked":null,"children":[{"type":"paragraph","children":[{"type":"text","value":"Gaussian Kernel","position":{"start":{"line":33,"column":3,"offset":552},"end":{"line":33,"column":18,"offset":567},"indent":[]}}],"position":{"start":{"line":33,"column":3,"offset":552},"end":{"line":33,"column":18,"offset":567},"indent":[]}}],"position":{"start":{"line":33,"column":1,"offset":550},"end":{"line":33,"column":18,"offset":567},"indent":[]}},{"type":"listItem","spread":false,"checked":null,"children":[{"type":"paragraph","children":[{"type":"text","value":"Exponential Kernel","position":{"start":{"line":34,"column":3,"offset":570},"end":{"line":34,"column":21,"offset":588},"indent":[]}}],"position":{"start":{"line":34,"column":3,"offset":570},"end":{"line":34,"column":21,"offset":588},"indent":[]}}],"position":{"start":{"line":34,"column":1,"offset":568},"end":{"line":34,"column":21,"offset":588},"indent":[]}},{"type":"listItem","spread":false,"checked":null,"children":[{"type":"paragraph","children":[{"type":"text","value":"Polynomial Kernel","position":{"start":{"line":35,"column":3,"offset":591},"end":{"line":35,"column":20,"offset":608},"indent":[]}}],"position":{"start":{"line":35,"column":3,"offset":591},"end":{"line":35,"column":20,"offset":608},"indent":[]}}],"position":{"start":{"line":35,"column":1,"offset":589},"end":{"line":35,"column":20,"offset":608},"indent":[]}},{"type":"listItem","spread":false,"checked":null,"children":[{"type":"paragraph","children":[{"type":"text","value":"Hybrid Kernel","position":{"start":{"line":36,"column":3,"offset":611},"end":{"line":36,"column":16,"offset":624},"indent":[]}}],"position":{"start":{"line":36,"column":3,"offset":611},"end":{"line":36,"column":16,"offset":624},"indent":[]}}],"position":{"start":{"line":36,"column":1,"offset":609},"end":{"line":36,"column":16,"offset":624},"indent":[]}},{"type":"listItem","spread":false,"checked":null,"children":[{"type":"paragraph","children":[{"type":"text","value":"Sigmoidal","position":{"start":{"line":37,"column":3,"offset":627},"end":{"line":37,"column":12,"offset":636},"indent":[]}}],"position":{"start":{"line":37,"column":3,"offset":627},"end":{"line":37,"column":12,"offset":636},"indent":[]}}],"position":{"start":{"line":37,"column":1,"offset":625},"end":{"line":37,"column":12,"offset":636},"indent":[]}}],"position":{"start":{"line":32,"column":1,"offset":534},"end":{"line":37,"column":12,"offset":636},"indent":[1,1,1,1,1]}},{"type":"thematicBreak","position":{"start":{"line":39,"column":1,"offset":638},"end":{"line":39,"column":4,"offset":641},"indent":[]}},{"type":"export","value":"export const _frontmatter = {\"title\":\"<파이썬을 이용한 빅데이터 분석> ch5 SVM\",\"date\":\"2020-08-13T00:00:00.000Z\",\"tags\":[\"Python\",\"BigData\",\"MachineLearning\"]}","position":{"start":{"line":43,"column":1,"offset":645},"end":{"line":43,"column":147,"offset":791},"indent":[]}}],"position":{"start":{"line":1,"column":1,"offset":0},"end":{"line":43,"column":147,"offset":791}}},"scopeImports":["import * as React from 'react'"],"scopeIdentifiers":["React"],"body":"function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsx mdx */\nvar _frontmatter = {\n  \"title\": \"<파이썬을 이용한 빅데이터 분석> ch5 SVM\",\n  \"date\": \"2020-08-13T00:00:00.000Z\",\n  \"tags\": [\"Python\", \"BigData\", \"MachineLearning\"]\n};\n\nvar makeShortcode = function makeShortcode(name) {\n  return function MDXDefaultShortcode(props) {\n    console.warn(\"Component '\" + name + \"' was not imported, exported, or provided by MDXProvider as global scope\");\n    return mdx(\"div\", props);\n  };\n};\n\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, [\"components\"]);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"p\", null, \"SVM\\uC740 \\uBD84\\uB958, \\uD68C\\uADC0\\uC5D0 \\uC0AC\\uC6A9\\uD560 \\uC218 \\uC788\\uB294 \\uAE30\\uACC4\\uD559\\uC2B5 \\uC54C\\uACE0\\uB9AC\\uC998.\"), mdx(\"p\", null, \"n\\uCC28\\uC6D0 \\uACF5\\uAC04\\uC5D0 \\uC788\\uB294 \\uAC01 \\uB370\\uC774\\uD130\\uB97C, \\uAC00\\uC7A5 \\uC798 \\uAD6C\\uBD84\\uD558\\uB294 \\uCD08\\uD3C9\\uBA74, \\uACBD\\uACC4\\uC120 \\uB610\\uB294 \\uBA74\\uC744 \\uCC3E\\uB294 \\uAC83\"), mdx(\"p\", null, \"SVM\\uC740 Margin (\\uCD08\\uD3C9\\uBA74\\uC5D0\\uC11C \\uAC00\\uC7A5 \\uAC00\\uAE4C\\uC774\\uC5D0 \\uC788\\uB294 \\uC810\\uACFC \\uCD08\\uD3C9\\uBA74\\uC0AC\\uC774\\uC758 \\uAC70\\uB9AC)\\uC744 \\uC6B0\\uC120\\uC73C\\uB85C \\uD574\\uC11C \\uBD84\\uB958\"), mdx(\"p\", null, \"SVM\\uC740 \\uC120\\uD615\\uBD84\\uB958\\uC640 \\uBE44\\uC120\\uD615\\uBD84\\uB958\\uC5D0 \\uC0AC\\uC6A9\"), mdx(\"p\", null, \"\\uBE44\\uC120\\uD615 \\uBD84\\uB958\\uB97C \\uD558\\uAE30 \\uC704\\uD574\\uC11C\\uB294 \\uC8FC\\uC5B4\\uC9C4 \\uB370\\uC774\\uD130\\uB97C \\uACE0\\uCC28\\uC6D0 \\uD2B9\\uC9D5 \\uACF5\\uAC04\\uC73C\\uB85C \\uC0AC\\uC0C1\\uD558\\uB294 \\uC791\\uC5C5\\uC774 \\uD544\\uC694\\uD558\\uB2E4.\\n\\uC774 \\uC791\\uC5C5\\uC744 \\uD6A8\\uC728\\uC801\\uC73C\\uB85C \\uC2E4\\uD589\\uD558\\uAE30 \\uC704\\uD574 \\uCEE4\\uB110\\uC744 \\uC774\\uC6A9\"), mdx(\"p\", null, \"\\uC8FC\\uC694 \\uCEE4\\uB110\\uC740 Linear Kernel, Polynomial Kernel, Radial Basis Function\"), mdx(\"p\", null, \"\\uCEE4\\uB110\\uC758 \\uD30C\\uB77C\\uBBF8\\uD130\\uB97C \\uC801\\uC808\\uD788 \\uC870\\uC808\\uD558\\uC5EC \\uC624\\uBC84\\uD53C\\uD305\\uC744 \\uB9C9\\uC544\\uC57C \\uD568\"), mdx(\"h3\", null, \"\\uC18C\\uD504\\uD2B8 \\uB9C8\\uC9C4 \\uC120\\uD615 SVM \\uBD84\\uB958\"), mdx(\"p\", null, \"Hard Margin \\uBD84\\uB958\\uB294 \\uC644\\uBCBD\\uD558\\uAC8C \\uBD84\\uB958\\uD558\\uC9C0\\uB9CC \\uBA87 \\uAC1C\\uC758 \\uB178\\uC774\\uC988\\uB85C \\uC778\\uD574 \\uCD08\\uD3C9\\uBA74\\uC744 \\uC798\\uBABB \\uAD6C\\uD560 \\uC218\\uB3C4 \\uC788\\uC74C\"), mdx(\"p\", null, \"\\uC774\\uC5D0 \\uB300\\uD55C \\uBCF4\\uC644\\uC73C\\uB85C Soft margin. \\uC11C\\uD3EC\\uD2B8 \\uBCA1\\uD130\\uAC00 \\uC704\\uCE58\\uD55C \\uACBD\\uACC4\\uC120\\uC5D0 \\uC5EC\\uC720 \\uBCC0\\uC218\\uB97C \\uB450\\uC5B4 \\uB178\\uC774\\uC988\\uB4E4\\uC744 \\uBB34\\uC2DC\\uD558\\uACE0 \\uCD08\\uD3C9\\uBA74\\uC744 \\uADF8\\uB9BC\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Primal \\uACF5\\uC2DD\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Dual \\uACF5\\uC2DD\")), mdx(\"h3\", null, \"\\uB9CE\\uC774 \\uC0AC\\uC6A9\\uD558\\uB294 \\uCEE4\\uB110\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Linear Kernel\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Gaussian Kernel\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Exponential Kernel\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Polynomial Kernel\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Hybrid Kernel\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Sigmoidal\")), mdx(\"hr\", null));\n}\n;\nMDXContent.isMDXComponent = true;","rawMDXOutput":"/* @jsx mdx */\nimport { mdx } from '@mdx-js/react';\n/* @jsx mdx */\n\nexport const _frontmatter = {\n  \"title\": \"<파이썬을 이용한 빅데이터 분석> ch5 SVM\",\n  \"date\": \"2020-08-13T00:00:00.000Z\",\n  \"tags\": [\"Python\", \"BigData\", \"MachineLearning\"]\n};\nconst makeShortcode = name => function MDXDefaultShortcode(props) {\n  console.warn(\"Component '\" + name + \"' was not imported, exported, or provided by MDXProvider as global scope\")\n  return <div {...props}/>\n};\n\nconst layoutProps = {\n  _frontmatter\n};\nconst MDXLayout = \"wrapper\"\nexport default function MDXContent({\n  components,\n  ...props\n}) {\n  return <MDXLayout {...layoutProps} {...props} components={components} mdxType=\"MDXLayout\">\n    <p>{`SVM은 분류, 회귀에 사용할 수 있는 기계학습 알고리즘.`}</p>\n    <p>{`n차원 공간에 있는 각 데이터를, 가장 잘 구분하는 초평면, 경계선 또는 면을 찾는 것`}</p>\n    <p>{`SVM은 Margin (초평면에서 가장 가까이에 있는 점과 초평면사이의 거리)을 우선으로 해서 분류`}</p>\n    <p>{`SVM은 선형분류와 비선형분류에 사용`}</p>\n    <p>{`비선형 분류를 하기 위해서는 주어진 데이터를 고차원 특징 공간으로 사상하는 작업이 필요하다.\n이 작업을 효율적으로 실행하기 위해 커널을 이용`}</p>\n    <p>{`주요 커널은 Linear Kernel, Polynomial Kernel, Radial Basis Function`}</p>\n    <p>{`커널의 파라미터를 적절히 조절하여 오버피팅을 막아야 함`}</p>\n    <h3>{`소프트 마진 선형 SVM 분류`}</h3>\n    <p>{`Hard Margin 분류는 완벽하게 분류하지만 몇 개의 노이즈로 인해 초평면을 잘못 구할 수도 있음`}</p>\n    <p>{`이에 대한 보완으로 Soft margin. 서포트 벡터가 위치한 경계선에 여유 변수를 두어 노이즈들을 무시하고 초평면을 그림`}</p>\n    <ul>\n      <li parentName=\"ul\">{`Primal 공식`}</li>\n      <li parentName=\"ul\">{`Dual 공식`}</li>\n    </ul>\n    <h3>{`많이 사용하는 커널`}</h3>\n    <ul>\n      <li parentName=\"ul\">{`Linear Kernel`}</li>\n      <li parentName=\"ul\">{`Gaussian Kernel`}</li>\n      <li parentName=\"ul\">{`Exponential Kernel`}</li>\n      <li parentName=\"ul\">{`Polynomial Kernel`}</li>\n      <li parentName=\"ul\">{`Hybrid Kernel`}</li>\n      <li parentName=\"ul\">{`Sigmoidal`}</li>\n    </ul>\n    <hr></hr>\n\n    </MDXLayout>;\n}\n\n;\nMDXContent.isMDXComponent = true;"}}