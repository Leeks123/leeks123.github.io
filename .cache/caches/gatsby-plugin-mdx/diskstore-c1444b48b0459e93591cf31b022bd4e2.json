{"expireTime":9007200852499541000,"key":"gatsby-plugin-mdx-entire-payload-58224c7358944c95562c16b070a4c4b5-","val":{"mdast":{"type":"root","children":[{"type":"paragraph","children":[{"type":"text","value":"수학에서의 집학과 같은 개념\n중복이 없는 항목들이 모인 것\n(중복 허용하려면 MultiSet)","position":{"start":{"line":2,"column":1,"offset":1},"end":{"line":4,"column":20,"offset":53},"indent":[1,1]}}],"position":{"start":{"line":2,"column":1,"offset":1},"end":{"line":4,"column":20,"offset":53},"indent":[1,1]}},{"type":"paragraph","children":[{"type":"text","value":"순서가 필요 없고, 고유 값을 원하는 경우 최선의 자료구조\n데이터를 비순차적으로 저장할 수 있는 자료구조","position":{"start":{"line":6,"column":1,"offset":55},"end":{"line":7,"column":26,"offset":113},"indent":[1]}}],"position":{"start":{"line":6,"column":1,"offset":55},"end":{"line":7,"column":26,"offset":113},"indent":[1]}},{"type":"paragraph","children":[{"type":"text","value":"중복된 값을 골라내야 할 때, 빠른 Look Up을 해야 할 때, 순서는 상관없을 때 사용","position":{"start":{"line":9,"column":1,"offset":115},"end":{"line":9,"column":51,"offset":165},"indent":[]}}],"position":{"start":{"line":9,"column":1,"offset":115},"end":{"line":9,"column":51,"offset":165},"indent":[]}},{"type":"paragraph","children":[{"type":"text","value":"균형잡힌 이진트리. 노드기반 컨테이너\n원소 삽입과 삭제, 탐색 등의 연산은 O(logn)을 보장\n삽입 시 자동으로 정렬. 디폴트 정렬은 오름차순","position":{"start":{"line":11,"column":1,"offset":167},"end":{"line":13,"column":27,"offset":247},"indent":[1,1]}}],"position":{"start":{"line":11,"column":1,"offset":167},"end":{"line":13,"column":27,"offset":247},"indent":[1,1]}},{"type":"paragraph","children":[{"type":"text","value":"연관 컨테이너 중 하나. key를 바탕으로 대응하는 값을 얻을 수 있는 구조","position":{"start":{"line":15,"column":1,"offset":249},"end":{"line":15,"column":43,"offset":291},"indent":[]}}],"position":{"start":{"line":15,"column":1,"offset":249},"end":{"line":15,"column":43,"offset":291},"indent":[]}},{"type":"code","lang":"cpp","meta":null,"value":"#include <iostream>\n#include <set>\nusing namespace std;\nint main(){\n    //int 자료형을 저장하는 균형잡힌 이진트리 생성\n    set<int> s;\n    \n    //원소 삽입\n    s.insert(5);\n    s.insert(4);\n    \n    // 2번째 원소 삭제\n    s.erase(++s.begin());\n    \n    //6값을 가지는 원소를 찾음 있다면 해당 원소의 주소값,  없다면 s.end()리턴\n    if(s.find(6)!=s.end())\n        printf(\"존재합니다.\\n\");\n    else\n        printf(\"없습니다.\\n\");\n    \n    //저장된 원소의 수를 리턴\n    printf(\"%d\\n\", s.size());\n    \n    // 원소값에 해당하는 개수를 반환\n    printf(\"%d\\n\", s.count(4)); // 있으면 1, 없으면 0\n    \n    //모든 원소 삭제\n    s.clear();\n\n    return 0;\n}","position":{"start":{"line":17,"column":1,"offset":293},"end":{"line":49,"column":4,"offset":851},"indent":[1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1]}},{"type":"export","value":"export const _frontmatter = {\"title\":\"CPP STL - Set\",\"date\":\"2020-08-07T00:00:00.000Z\",\"tags\":[\"CPP\"]}","position":{"start":{"line":52,"column":1,"offset":854},"end":{"line":52,"column":103,"offset":956},"indent":[]}}],"position":{"start":{"line":1,"column":1,"offset":0},"end":{"line":52,"column":103,"offset":956}}},"scopeImports":["import * as React from 'react'"],"scopeIdentifiers":["React"],"body":"function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsx mdx */\nvar _frontmatter = {\n  \"title\": \"CPP STL - Set\",\n  \"date\": \"2020-08-07T00:00:00.000Z\",\n  \"tags\": [\"CPP\"]\n};\n\nvar makeShortcode = function makeShortcode(name) {\n  return function MDXDefaultShortcode(props) {\n    console.warn(\"Component '\" + name + \"' was not imported, exported, or provided by MDXProvider as global scope\");\n    return mdx(\"div\", props);\n  };\n};\n\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, [\"components\"]);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"p\", null, \"\\uC218\\uD559\\uC5D0\\uC11C\\uC758 \\uC9D1\\uD559\\uACFC \\uAC19\\uC740 \\uAC1C\\uB150\\n\\uC911\\uBCF5\\uC774 \\uC5C6\\uB294 \\uD56D\\uBAA9\\uB4E4\\uC774 \\uBAA8\\uC778 \\uAC83\\n(\\uC911\\uBCF5 \\uD5C8\\uC6A9\\uD558\\uB824\\uBA74 MultiSet)\"), mdx(\"p\", null, \"\\uC21C\\uC11C\\uAC00 \\uD544\\uC694 \\uC5C6\\uACE0, \\uACE0\\uC720 \\uAC12\\uC744 \\uC6D0\\uD558\\uB294 \\uACBD\\uC6B0 \\uCD5C\\uC120\\uC758 \\uC790\\uB8CC\\uAD6C\\uC870\\n\\uB370\\uC774\\uD130\\uB97C \\uBE44\\uC21C\\uCC28\\uC801\\uC73C\\uB85C \\uC800\\uC7A5\\uD560 \\uC218 \\uC788\\uB294 \\uC790\\uB8CC\\uAD6C\\uC870\"), mdx(\"p\", null, \"\\uC911\\uBCF5\\uB41C \\uAC12\\uC744 \\uACE8\\uB77C\\uB0B4\\uC57C \\uD560 \\uB54C, \\uBE60\\uB978 Look Up\\uC744 \\uD574\\uC57C \\uD560 \\uB54C, \\uC21C\\uC11C\\uB294 \\uC0C1\\uAD00\\uC5C6\\uC744 \\uB54C \\uC0AC\\uC6A9\"), mdx(\"p\", null, \"\\uADE0\\uD615\\uC7A1\\uD78C \\uC774\\uC9C4\\uD2B8\\uB9AC. \\uB178\\uB4DC\\uAE30\\uBC18 \\uCEE8\\uD14C\\uC774\\uB108\\n\\uC6D0\\uC18C \\uC0BD\\uC785\\uACFC \\uC0AD\\uC81C, \\uD0D0\\uC0C9 \\uB4F1\\uC758 \\uC5F0\\uC0B0\\uC740 O(logn)\\uC744 \\uBCF4\\uC7A5\\n\\uC0BD\\uC785 \\uC2DC \\uC790\\uB3D9\\uC73C\\uB85C \\uC815\\uB82C. \\uB514\\uD3F4\\uD2B8 \\uC815\\uB82C\\uC740 \\uC624\\uB984\\uCC28\\uC21C\"), mdx(\"p\", null, \"\\uC5F0\\uAD00 \\uCEE8\\uD14C\\uC774\\uB108 \\uC911 \\uD558\\uB098. key\\uB97C \\uBC14\\uD0D5\\uC73C\\uB85C \\uB300\\uC751\\uD558\\uB294 \\uAC12\\uC744 \\uC5BB\\uC744 \\uC218 \\uC788\\uB294 \\uAD6C\\uC870\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-cpp\"\n  }), \"#include <iostream>\\n#include <set>\\nusing namespace std;\\nint main(){\\n    //int \\uC790\\uB8CC\\uD615\\uC744 \\uC800\\uC7A5\\uD558\\uB294 \\uADE0\\uD615\\uC7A1\\uD78C \\uC774\\uC9C4\\uD2B8\\uB9AC \\uC0DD\\uC131\\n    set<int> s;\\n    \\n    //\\uC6D0\\uC18C \\uC0BD\\uC785\\n    s.insert(5);\\n    s.insert(4);\\n    \\n    // 2\\uBC88\\uC9F8 \\uC6D0\\uC18C \\uC0AD\\uC81C\\n    s.erase(++s.begin());\\n    \\n    //6\\uAC12\\uC744 \\uAC00\\uC9C0\\uB294 \\uC6D0\\uC18C\\uB97C \\uCC3E\\uC74C \\uC788\\uB2E4\\uBA74 \\uD574\\uB2F9 \\uC6D0\\uC18C\\uC758 \\uC8FC\\uC18C\\uAC12,  \\uC5C6\\uB2E4\\uBA74 s.end()\\uB9AC\\uD134\\n    if(s.find(6)!=s.end())\\n        printf(\\\"\\uC874\\uC7AC\\uD569\\uB2C8\\uB2E4.\\\\n\\\");\\n    else\\n        printf(\\\"\\uC5C6\\uC2B5\\uB2C8\\uB2E4.\\\\n\\\");\\n    \\n    //\\uC800\\uC7A5\\uB41C \\uC6D0\\uC18C\\uC758 \\uC218\\uB97C \\uB9AC\\uD134\\n    printf(\\\"%d\\\\n\\\", s.size());\\n    \\n    // \\uC6D0\\uC18C\\uAC12\\uC5D0 \\uD574\\uB2F9\\uD558\\uB294 \\uAC1C\\uC218\\uB97C \\uBC18\\uD658\\n    printf(\\\"%d\\\\n\\\", s.count(4)); // \\uC788\\uC73C\\uBA74 1, \\uC5C6\\uC73C\\uBA74 0\\n    \\n    //\\uBAA8\\uB4E0 \\uC6D0\\uC18C \\uC0AD\\uC81C\\n    s.clear();\\n\\n    return 0;\\n}\\n\")));\n}\n;\nMDXContent.isMDXComponent = true;","rawMDXOutput":"/* @jsx mdx */\nimport { mdx } from '@mdx-js/react';\n/* @jsx mdx */\n\nexport const _frontmatter = {\n  \"title\": \"CPP STL - Set\",\n  \"date\": \"2020-08-07T00:00:00.000Z\",\n  \"tags\": [\"CPP\"]\n};\nconst makeShortcode = name => function MDXDefaultShortcode(props) {\n  console.warn(\"Component '\" + name + \"' was not imported, exported, or provided by MDXProvider as global scope\")\n  return <div {...props}/>\n};\n\nconst layoutProps = {\n  _frontmatter\n};\nconst MDXLayout = \"wrapper\"\nexport default function MDXContent({\n  components,\n  ...props\n}) {\n  return <MDXLayout {...layoutProps} {...props} components={components} mdxType=\"MDXLayout\">\n    <p>{`수학에서의 집학과 같은 개념\n중복이 없는 항목들이 모인 것\n(중복 허용하려면 MultiSet)`}</p>\n    <p>{`순서가 필요 없고, 고유 값을 원하는 경우 최선의 자료구조\n데이터를 비순차적으로 저장할 수 있는 자료구조`}</p>\n    <p>{`중복된 값을 골라내야 할 때, 빠른 Look Up을 해야 할 때, 순서는 상관없을 때 사용`}</p>\n    <p>{`균형잡힌 이진트리. 노드기반 컨테이너\n원소 삽입과 삭제, 탐색 등의 연산은 O(logn)을 보장\n삽입 시 자동으로 정렬. 디폴트 정렬은 오름차순`}</p>\n    <p>{`연관 컨테이너 중 하나. key를 바탕으로 대응하는 값을 얻을 수 있는 구조`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-cpp\"\n      }}>{`#include <iostream>\n#include <set>\nusing namespace std;\nint main(){\n    //int 자료형을 저장하는 균형잡힌 이진트리 생성\n    set<int> s;\n    \n    //원소 삽입\n    s.insert(5);\n    s.insert(4);\n    \n    // 2번째 원소 삭제\n    s.erase(++s.begin());\n    \n    //6값을 가지는 원소를 찾음 있다면 해당 원소의 주소값,  없다면 s.end()리턴\n    if(s.find(6)!=s.end())\n        printf(\"존재합니다.\\\\n\");\n    else\n        printf(\"없습니다.\\\\n\");\n    \n    //저장된 원소의 수를 리턴\n    printf(\"%d\\\\n\", s.size());\n    \n    // 원소값에 해당하는 개수를 반환\n    printf(\"%d\\\\n\", s.count(4)); // 있으면 1, 없으면 0\n    \n    //모든 원소 삭제\n    s.clear();\n\n    return 0;\n}\n`}</code></pre>\n\n    </MDXLayout>;\n}\n\n;\nMDXContent.isMDXComponent = true;"}}